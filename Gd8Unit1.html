<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>è‹±èªå¥å­é‡çµ„éŠæˆ² - Unit 1</title>
    
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- html2canvas CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    
    <style>
        :root {
            --primary-color: #667eea;
            --secondary-color: #38bdf8;
            --success-color: #10b981;
            --error-color: #ef4444;
            --shadow-3d: 0 2px 0 rgba(0, 0, 0, 0.1), 0 4px 8px rgba(0, 0, 0, 0.15);
            --game-font-size: 18px;
        }

        * {
            -webkit-tap-highlight-color: transparent;
        }

        body {
            overscroll-behavior: none;
            touch-action: pan-y;
            -webkit-overflow-scrolling: touch;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        }

        /* å‹•ç•«å®šç¾© */
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* æŒ‰éˆ• 3D æ•ˆæœ */
        .btn-3d {
            box-shadow: var(--shadow-3d);
            transform: translateY(0);
            transition: all 0.15s ease;
        }

        .btn-3d:active {
            transform: translateY(2px);
            box-shadow: 0 1px 0 rgba(0, 0, 0, 0.1);
        }

        /* éŠæˆ²å®¹å™¨ - é—œéµé…ç½® */
        #game-container {
            padding-bottom: 50vh;
            scroll-padding-bottom: 200px;
            min-height: 100vh;
        }

        /* å›ºå®šåº•æ¬„ */
        #bottom-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(255,255,255,0.98) 0%, rgba(255,255,255,0.95) 100%);
            backdrop-filter: blur(10px);
            border-top: 2px solid #e5e7eb;
            box-shadow: 0 -4px 6px rgba(0, 0, 0, 0.05);
            z-index: 50;
            padding-right: 3.5rem;
        }

        @media (min-width: 768px) {
            #bottom-bar {
                padding-right: 1rem;
            }
        }

        /* å­—åº«å®¹å™¨ */
        #word-bank {
            max-height: 35vh;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* æ§½ä½æ¨£å¼ */
        .slot {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 3em;
            height: 1.8em;
            padding: 0.2em 0.5em;
            border: 2px dashed #cbd5e1;
            border-radius: 0.375rem;
            background: white;
            font-size: var(--game-font-size);
            line-height: 1.4;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
            vertical-align: middle;
        }

        .slot.filled {
            border-style: solid;
            border-color: var(--primary-color);
            background: #ede9fe;
            font-weight: 600;
            color: #5b21b6;
        }

        .slot.correct-lock {
            border-color: var(--success-color);
            background: #d1fae5;
            color: #065f46;
        }

        .slot.wrong-shake {
            animation: shake 0.5s ease-in-out;
            border-color: var(--error-color);
            background: #fee2e2;
            color: #991b1b;
        }

        .slot.drop-zone {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 2px dashed white;
            transform: scale(1.05);
            color: white;
        }

        /* å­—å¡æ¨£å¼ */
        .word-card {
            display: inline-block;
            padding: 0.3em 0.6em;
            margin: 0.2rem;
            background: white;
            border: 2px solid var(--primary-color);
            border-radius: 0.375rem;
            cursor: grab;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            font-weight: 600;
            color: var(--primary-color);
            font-size: var(--game-font-size);
            line-height: 1.4;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: all 0.15s ease;
        }

        .word-card:active {
            cursor: grabbing;
            transform: scale(0.95);
        }

        .word-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
        }

        /* æ‹–å‹•è™›å½± */
        .dragging-clone {
            position: fixed;
            pointer-events: none;
            opacity: 0.8;
            transform: scale(1.05);
            z-index: 9999;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3) !important;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
        
        /* å…¨åŸŸç¦ç”¨é¸å–ï¼ˆéŠæˆ²é€²è¡Œæ™‚ï¼‰ */
        #game-screen, #word-bank, #sentences-container {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Toggle é–‹é—œ */
        .toggle-checkbox {
            appearance: none;
            width: 3rem;
            height: 1.5rem;
            background: #cbd5e1;
            border-radius: 9999px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-checkbox::after {
            content: '';
            position: absolute;
            width: 1.25rem;
            height: 1.25rem;
            background: white;
            border-radius: 50%;
            top: 0.125rem;
            left: 0.125rem;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-checkbox:checked {
            background: var(--primary-color);
        }

        .toggle-checkbox:checked::after {
            transform: translateX(1.5rem);
        }

        /* é€²åº¦æŒ‡ç¤ºå™¨ */
        .progress-indicator {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 1.5rem;
            height: 1.5rem;
            border-radius: 50%;
            background: #e2e8f0;
            color: #64748b;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .progress-indicator.completed {
            background: var(--success-color);
            color: white;
        }

        .progress-indicator.completed::after {
            content: 'âœ“';
        }

        /* é—œå¡æŒ‰éˆ• */
        .level-btn {
            min-width: 3.5rem;
            height: 3.5rem;
            font-weight: 600;
            font-size: 1rem;
            transition: all 0.2s ease;
        }

        .level-btn:hover {
            transform: translateY(-2px);
        }

        /* Toast é€šçŸ¥ */
        .toast {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            z-index: 9999;
            animation: fadeInUp 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .toast.success {
            background: var(--success-color);
            color: white;
        }

        .toast.error {
            background: var(--error-color);
            color: white;
        }

        .toast.warning {
            background: #f59e0b;
            color: white;
        }

        /* éš±è—å…ƒç´  */
        .hidden {
            display: none !important;
        }

        /* éŠæˆ²æ–‡å­— */
        .game-text {
            font-size: var(--game-font-size);
            line-height: 1.4;
            vertical-align: middle;
        }

        /* å¥å­åŒ…è£å™¨ */
        .sentence-wrapper {
            padding: 0.75rem 0;
            border-bottom: 1px dashed #e5e7eb;
            line-height: 1.4;
        }

        .sentence-wrapper:last-child {
            border-bottom: none;
        }
        
        .sentence-wrapper .mb-2 {
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }

        /* éŸ¿æ‡‰å¼èª¿æ•´ */
        @media (max-width: 640px) {
            .word-card {
                margin: 0.2rem;
                padding: 0.35em 0.7em;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-indigo-50 via-purple-50 to-pink-50 min-h-screen">

    <!-- Header -->
    <header id="game-header" class="hidden fixed top-0 left-0 right-0 bg-white shadow-md z-40 px-4 py-3">
        <div class="flex items-center justify-between max-w-4xl mx-auto">
            <button id="back-btn" class="flex items-center gap-2 px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors">
                <span>â†</span>
                <span>è¿”å›</span>
            </button>
            
            <div id="timer" class="text-2xl font-bold text-indigo-600">00:00</div>
            
            <div class="flex items-center gap-2">
                <button id="font-decrease" class="w-10 h-10 bg-gray-100 hover:bg-gray-200 rounded-lg font-bold transition-colors text-lg" title="ç¸®å°å­—é«”">A-</button>
                <button id="font-increase" class="w-10 h-10 bg-gray-100 hover:bg-gray-200 rounded-lg font-bold transition-colors text-lg" title="æ”¾å¤§å­—é«”">A+</button>
            </div>
        </div>
    </header>

    <!-- Home Screen -->
    <div id="home-screen" class="min-h-screen px-4 py-8">
        <div class="max-w-4xl mx-auto">
            <!-- Title -->
            <div class="text-center mb-8">
                <h1 class="text-4xl font-bold text-indigo-600 mb-2">è‹±èªå¥å­é‡çµ„éŠæˆ²</h1>
                <p class="text-gray-600">Unit 1 - The Steak Looks Yummy</p>
            </div>

            <!-- Difficulty Selector -->
            <div class="bg-white rounded-xl shadow-lg p-6 mb-8">
                <h2 class="text-xl font-bold text-gray-800 mb-4">é¸æ“‡é›£åº¦</h2>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <button class="difficulty-btn btn-3d px-6 py-4 bg-green-100 hover:bg-green-200 text-green-700 rounded-lg font-bold" data-difficulty="40">
                        ç°¡å–®<br><span class="text-sm">40%</span>
                    </button>
                    <button class="difficulty-btn btn-3d px-6 py-4 bg-blue-100 hover:bg-blue-200 text-blue-700 rounded-lg font-bold" data-difficulty="60">
                        æ™®é€š<br><span class="text-sm">60%</span>
                    </button>
                    <button class="difficulty-btn btn-3d px-6 py-4 bg-orange-100 hover:bg-orange-200 text-orange-700 rounded-lg font-bold" data-difficulty="80">
                        å›°é›£<br><span class="text-sm">80%</span>
                    </button>
                    <button class="difficulty-btn btn-3d px-6 py-4 bg-red-100 hover:bg-red-200 text-red-700 rounded-lg font-bold" data-difficulty="100">
                        å°ˆå®¶<br><span class="text-sm">100%</span>
                    </button>
                </div>
                <div id="current-difficulty" class="mt-4 text-center text-gray-600">
                    ç›®å‰é›£åº¦: <span class="font-bold text-indigo-600">60% (æ™®é€š)</span>
                </div>
            </div>

            <!-- Levels Container -->
            <div id="levels-container">
                <!-- Groups will be dynamically generated here -->
            </div>
        </div>
    </div>

    <!-- Game Screen -->
    <div id="game-screen" class="hidden pt-20 pb-64">
        <div id="game-container" class="max-w-4xl mx-auto px-4">
            <div class="bg-white rounded-xl shadow-lg p-6">
                <h2 id="level-title" class="text-2xl font-bold text-indigo-600 mb-6"></h2>
                <div id="sentences-container" class="space-y-4">
                    <!-- Sentences will be dynamically generated here -->
                </div>
            </div>
        </div>
    </div>

    <!-- Bottom Control Bar -->
    <div id="bottom-bar" class="hidden">
        <div class="max-w-4xl mx-auto px-4 py-4">
            <!-- Quick Fill Toggle -->
            <div class="flex items-center justify-between mb-4">
                <label class="flex items-center gap-3 cursor-pointer">
                    <input type="checkbox" id="quick-fill-toggle" class="toggle-checkbox">
                    <span class="font-semibold text-gray-700">å¿«é€Ÿå¡«å……æ¨¡å¼</span>
                </label>
                <button id="check-btn" class="btn-3d px-8 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold transition-colors">
                    æª¢æŸ¥ç­”æ¡ˆ
                </button>
            </div>
            
            <!-- Word Bank -->
            <div id="word-bank" class="flex flex-wrap gap-2 p-4 bg-gray-50 rounded-lg border-2 border-gray-200">
                <!-- Words will be dynamically generated here -->
            </div>
        </div>
    </div>

    <!-- End Screen -->
    <div id="end-screen" class="hidden min-h-screen px-4 py-8">
        <div class="max-w-4xl mx-auto">
            <div class="bg-white rounded-xl shadow-lg p-8 text-center">
                <div class="text-6xl mb-4">ğŸ‰</div>
                <h2 class="text-3xl font-bold text-indigo-600 mb-4">æ­å–œéé—œï¼</h2>
                
                <div class="grid grid-cols-2 gap-4 mb-6 max-w-md mx-auto">
                    <div class="bg-indigo-50 rounded-lg p-4">
                        <div class="text-sm text-gray-600">å®Œæˆæ™‚é–“</div>
                        <div id="final-time" class="text-2xl font-bold text-indigo-600">00:00</div>
                    </div>
                    <div class="bg-purple-50 rounded-lg p-4">
                        <div class="text-sm text-gray-600">é›£åº¦</div>
                        <div id="final-difficulty" class="text-2xl font-bold text-purple-600">60%</div>
                    </div>
                </div>

                <!-- Full Text Review -->
                <div class="bg-gray-50 rounded-lg p-6 mb-6 text-left">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">å®Œæ•´å…§å®¹å›é¡§</h3>
                    <div id="full-text-review" class="space-y-4">
                        <!-- Full sentences will be displayed here -->
                    </div>
                </div>

                <div class="flex flex-col sm:flex-row gap-4 justify-center">
                    <button id="download-report-btn" class="btn-3d px-8 py-3 bg-green-600 hover:bg-green-700 text-white rounded-lg font-bold transition-colors">
                        ä¸‹è¼‰å ±å‘Š
                    </button>
                    <button id="next-level-btn" class="btn-3d px-8 py-3 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold transition-colors">
                        ä¸‹ä¸€é—œ
                    </button>
                    <button id="back-home-btn" class="btn-3d px-8 py-3 bg-gray-600 hover:bg-gray-700 text-white rounded-lg font-bold transition-colors">
                        è¿”å›é¦–é 
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Report Container for Screenshot -->
    <div id="report-container" class="hidden" style="width: 800px; padding: 40px; background: white;">
        <div style="text-align: center; margin-bottom: 30px;">
            <h1 style="font-size: 32px; font-weight: bold; color: #667eea; margin-bottom: 10px;">å­¸ç¿’å ±å‘Š</h1>
            <p style="color: #64748b;" id="report-date"></p>
        </div>
        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 30px;">
            <div style="background: #f1f5f9; padding: 20px; border-radius: 12px;">
                <p style="color: #64748b; font-size: 14px;">é—œå¡</p>
                <p style="font-size: 24px; font-weight: bold; color: #667eea;" id="report-level"></p>
            </div>
            <div style="background: #f1f5f9; padding: 20px; border-radius: 12px;">
                <p style="color: #64748b; font-size: 14px;">å®Œæˆæ™‚é–“</p>
                <p style="font-size: 24px; font-weight: bold; color: #667eea;" id="report-time"></p>
            </div>
        </div>
        <div style="background: #f1f5f9; padding: 20px; border-radius: 12px;">
            <h3 style="font-size: 18px; font-weight: bold; color: #1e293b; margin-bottom: 15px;">å®Œæ•´å…§å®¹</h3>
            <div id="report-sentences" style="line-height: 2;"></div>
        </div>
    </div>

    <script>
        /* ========== 1. è³‡æ–™å±¤ ========== */
        const levelsDB = {
            'd1_1': {
                title: 'Talking About Countries',
                group: 'dialogue',
                groupName: 'Unit 1 - Dialogue',
                sentences: [
                    { en: "What's your country like, Ela?", zh: 'ä½ çš„åœ‹å®¶æ˜¯ä»€éº¼æ¨£å­ï¼ŒElaï¼Ÿ', id: 'd1_1_s1' },
                    { en: 'Turkey is bigger and colder than Taiwan.', zh: 'åœŸè€³å…¶æ¯”å°ç£æ›´å¤§ã€æ›´å†·ã€‚', id: 'd1_1_s2' },
                    { en: 'Do you like living in Taiwan?', zh: 'ä½ å–œæ­¡ä½åœ¨å°ç£å—ï¼Ÿ', id: 'd1_1_s3' },
                    { en: 'Life here is convenient.', zh: 'é€™è£¡çš„ç”Ÿæ´»å¾ˆä¾¿åˆ©ã€‚', id: 'd1_1_s4' }
                ]
            },
            'd1_2': {
                title: 'At the Restaurant',
                group: 'dialogue',
                groupName: 'Unit 1 - Dialogue',
                sentences: [
                    { en: 'May I take your order?', zh: 'å¯ä»¥ç‚ºæ‚¨é»é¤äº†å—ï¼Ÿ', id: 'd1_2_s1' },
                    { en: "I'd like the ham and cheese sandwich.", zh: 'æˆ‘æƒ³è¦ç«è…¿èµ·å¸ä¸‰æ˜æ²»ã€‚', id: 'd1_2_s2' },
                    { en: 'The steak looks yummy.', zh: 'é€™ç‰›æ’çœ‹èµ·ä¾†å¾ˆå¥½åƒã€‚', id: 'd1_2_s3' },
                    { en: 'How would you like your steak?', zh: 'æ‚¨çš„ç‰›æ’è¦å¹¾åˆ†ç†Ÿï¼Ÿ', id: 'd1_2_s4' }
                ]
            },
            'r1_1': {
                title: 'Cappadocia - Hot Air Balloon',
                group: 'reading',
                groupName: 'Unit 1 - Reading',
                sentences: [
                    { en: 'Cappadocia is better than any other place on earth for a hot-air balloon ride.', zh: 'å¡å¸•å¤šå¥‡äºæ˜¯åœ°çƒä¸Šç†±æ°£çƒé£›è¡Œæœ€æ£’çš„åœ°æ–¹ã€‚', id: 'r1_1_s1' },
                    { en: "The view from the balloon always brings smiles to people's faces.", zh: 'å¾ç†±æ°£çƒä¸Šçœ‹åˆ°çš„æ™¯è‰²ç¸½æ˜¯è®“äººå€‘éœ²å‡ºç¬‘å®¹ã€‚', id: 'r1_1_s2' },
                    { en: 'The land is unique.', zh: 'é€™ç‰‡åœŸåœ°å¾ˆç¨ç‰¹ã€‚', id: 'r1_1_s3' },
                    { en: 'There are tall rocks in many different shapes.', zh: 'æœ‰è¨±å¤šä¸åŒå½¢ç‹€çš„é«˜è³å²©çŸ³ã€‚', id: 'r1_1_s4' }
                ]
            },
            'g1_1': {
                title: 'Comparative Adjectives',
                group: 'grammar',
                groupName: 'Unit 1 - Grammar Practice',
                sentences: [
                    { en: 'Turkey is bigger than Taiwan.', zh: 'åœŸè€³å…¶æ¯”å°ç£å¤§ã€‚', id: 'g1_1_s1' },
                    { en: 'Getting around in Taiwan is easier than in Turkey.', zh: 'åœ¨å°ç£æ—…è¡Œæ¯”åœ¨åœŸè€³å…¶å®¹æ˜“ã€‚', id: 'g1_1_s2' },
                    { en: 'The blue plates are cheaper than the purple ones.', zh: 'è—è‰²ç›¤å­æ¯”ç´«è‰²ç›¤å­ä¾¿å®œã€‚', id: 'g1_1_s3' }
                ]
            },
            'g1_2': {
                title: 'More + Adjective',
                group: 'grammar',
                groupName: 'Unit 1 - Grammar Practice',
                sentences: [
                    { en: 'The beef dishes are more delicious than the pork dishes.', zh: 'ç‰›è‚‰æ–™ç†æ¯”è±¬è‚‰æ–™ç†æ›´ç¾å‘³ã€‚', id: 'g1_2_s1' },
                    { en: 'The breakfast shop is more popular than the coffee shop.', zh: 'æ—©é¤åº—æ¯”å’–å•¡åº—æ›´å—æ­¡è¿ã€‚', id: 'g1_2_s2' },
                    { en: 'Playing cards is more interesting than playing video games.', zh: 'ç©æ’²å…‹ç‰Œæ¯”ç©é›»å‹•æ›´æœ‰è¶£ã€‚', id: 'g1_2_s3' }
                ]
            },
            'g1_3': {
                title: 'Linking Verbs',
                group: 'grammar',
                groupName: 'Unit 1 - Grammar Practice',
                sentences: [
                    { en: 'How does the trash smell?', zh: 'é€™åƒåœ¾èèµ·ä¾†å¦‚ä½•ï¼Ÿ', id: 'g1_3_s1' },
                    { en: 'It smells terrible.', zh: 'å®ƒèèµ·ä¾†å¾ˆç³Ÿã€‚', id: 'g1_3_s2' },
                    { en: 'How does the juice taste?', zh: 'æœæ±åšèµ·ä¾†å¦‚ä½•ï¼Ÿ', id: 'g1_3_s3' },
                    { en: 'It tastes sweet.', zh: 'å®ƒåšèµ·ä¾†å¾ˆç”œã€‚', id: 'g1_3_s4' }
                ]
            },
            'g1_4': {
                title: 'Get/Become/Turn',
                group: 'grammar',
                groupName: 'Unit 1 - Grammar Practice',
                sentences: [
                    { en: 'The students got hungry after PE class.', zh: 'å­¸ç”Ÿåœ¨é«”è‚²èª²å¾Œè®Šé¤“äº†ã€‚', id: 'g1_4_s1' },
                    { en: 'The weather became cold after October.', zh: 'åæœˆå¾Œå¤©æ°£è®Šå†·äº†ã€‚', id: 'g1_4_s2' },
                    { en: 'The sky turned dark before the man got home.', zh: 'å¤©ç©ºåœ¨é‚£å€‹ç”·äººå›å®¶å‰è®Šé»‘äº†ã€‚', id: 'g1_4_s3' }
                ]
            },
            'g1_5': {
                title: 'As... As...',
                group: 'grammar',
                groupName: 'Unit 1 - Grammar Practice',
                sentences: [
                    { en: 'Ela is as hungry as a bear.', zh: 'Ela åƒç†Šä¸€æ¨£é¤“ã€‚', id: 'g1_5_s1' },
                    { en: 'The pork rice is as delicious as the beef noodles.', zh: 'è±¬è‚‰é£¯å’Œç‰›è‚‰éºµä¸€æ¨£ç¾å‘³ã€‚', id: 'g1_5_s2' },
                    { en: "Bobby's Pie Shop is as old as Oliver's.", zh: "Bobby çš„æ´¾åº—å’Œ Oliver çš„ä¸€æ¨£è€ã€‚", id: 'g1_5_s3' }
                ]
            }
        };

        const groupsConfig = [
            {
                id: 'dialogue',
                name: 'Unit 1 - Dialogue',
                icon: 'ğŸ’¬',
                levels: ['d1_1', 'd1_2']
            },
            {
                id: 'reading',
                name: 'Unit 1 - Reading',
                icon: 'ğŸ“–',
                levels: ['r1_1']
            },
            {
                id: 'grammar',
                name: 'Unit 1 - Grammar Practice',
                icon: 'âœï¸',
                levels: ['g1_1', 'g1_2', 'g1_3', 'g1_4', 'g1_5']
            }
        ];

        /* ========== 2. å…¨åŸŸç‹€æ…‹ ========== */
        let currentLevel = null;
        let currentDifficulty = 60;
        let gameTimer = null;
        let startTime = 0;
        let selectedWord = null;
        let quickFillMode = false;

        /* ========== 3. æ‹–æ”¾ç‹€æ…‹ ========== */
        let dragState = {
            isDragging: false,
            sourceElement: null,
            sourceType: null,
            ghostElement: null,
            touchIdentifier: null
        };

        /* ========== 4. å·¥å…·å‡½æ•¸ ========== */
        function shuffleArray(arr) {
            const result = [...arr];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        const storage = {
            get(key, defaultValue = null) {
                try {
                    const data = localStorage.getItem(key);
                    return data ? JSON.parse(data) : defaultValue;
                } catch (error) {
                    console.error('Storage read error:', error);
                    return defaultValue;
                }
            },
            set(key, value) {
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch (error) {
                    console.error('Storage write error:', error);
                    if (error.name === 'QuotaExceededError') {
                        showToast('å„²å­˜ç©ºé–“å·²æ»¿', 'error');
                    }
                    return false;
                }
            },
            remove(key) {
                try {
                    localStorage.removeItem(key);
                    return true;
                } catch (error) {
                    console.error('Storage remove error:', error);
                    return false;
                }
            }
        };

        function showToast(message, type = 'success') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        /* ========== 5. UI æ§åˆ¶å™¨ ========== */
        function showHomeScreen() {
            document.getElementById('home-screen').classList.remove('hidden');
            document.getElementById('game-screen').classList.add('hidden');
            document.getElementById('end-screen').classList.add('hidden');
            document.getElementById('game-header').classList.add('hidden');
            document.getElementById('bottom-bar').classList.add('hidden');
            renderLevels();
        }

        function showGameScreen() {
            document.getElementById('home-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.remove('hidden');
            document.getElementById('end-screen').classList.add('hidden');
            document.getElementById('game-header').classList.remove('hidden');
            document.getElementById('bottom-bar').classList.remove('hidden');
        }

        function showEndScreen() {
            document.getElementById('home-screen').classList.add('hidden');
            document.getElementById('game-screen').classList.add('hidden');
            document.getElementById('end-screen').classList.remove('hidden');
            document.getElementById('game-header').classList.add('hidden');
            document.getElementById('bottom-bar').classList.add('hidden');
        }

        function renderLevels() {
            const container = document.getElementById('levels-container');
            const progress = storage.get('game-progress', {});
            
            container.innerHTML = groupsConfig.map(group => `
                <div class="bg-white rounded-xl shadow-lg p-6 mb-6">
                    <h3 class="text-xl font-bold text-gray-800 mb-4">
                        <span class="text-2xl mr-2">${group.icon}</span>
                        ${group.name}
                    </h3>
                    <div class="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-3">
                        ${group.levels.map((levelId, index) => {
                            const isCompleted = progress[levelId]?.completed;
                            return `
                                <button class="level-btn btn-3d ${isCompleted ? 'bg-green-100 text-green-700' : 'bg-indigo-100 text-indigo-700'} hover:bg-indigo-200 rounded-lg relative" data-level="${levelId}">
                                    ${index + 1}
                                    ${isCompleted ? '<div class="progress-indicator completed absolute -top-1 -right-1"></div>' : ''}
                                </button>
                            `;
                        }).join('')}
                    </div>
                </div>
            `).join('');

            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const levelId = btn.dataset.level;
                    startLevel(levelId);
                });
            });
        }

        /* ========== 6. éŠæˆ²é‚è¼¯ ========== */
        function startLevel(levelId) {
            currentLevel = levelId;
            const level = levelsDB[levelId];
            
            if (!level) {
                showToast('é—œå¡è³‡æ–™éŒ¯èª¤', 'error');
                return;
            }

            // é‡ç½®æª¢æŸ¥ç‹€æ…‹
            storage.set('last-check-had-empty', false);

            showGameScreen();
            document.getElementById('level-title').textContent = level.title;
            generateSentences(level.sentences);
            startTimer();
        }

        function generateSentences(sentences) {
            const container = document.getElementById('sentences-container');
            const wordBank = document.getElementById('word-bank');
            const allWords = [];
            
            container.innerHTML = sentences.map((sentence, sentenceIndex) => {
                // åˆ†é›¢æ¨™é»ç¬¦è™Ÿï¼ˆå¥å°¾çš„ . ! ? , ç­‰ï¼‰
                let punctuation = '';
                let cleanSentence = sentence.en.trim();
                const lastChar = cleanSentence[cleanSentence.length - 1];
                
                if (['.', '!', '?', ',', ';', ':'].includes(lastChar)) {
                    punctuation = lastChar;
                    cleanSentence = cleanSentence.slice(0, -1).trim();
                }
                
                const words = cleanSentence.split(' ');
                const ratio = currentDifficulty / 100;
                const blankCount = Math.max(1, Math.ceil(words.length * ratio));
                
                const functionalWords = ['a', 'an', 'the', 'is', 'are', 'am', 'was', 'were', 'to', 'of', 'in', 'on', 'at'];
                const contentWords = words.filter(w => !functionalWords.includes(w.toLowerCase()));
                
                const shuffledWords = shuffleArray(words);
                const blanksSet = new Set(
                    shuffledWords.slice(0, Math.min(blankCount, contentWords.length > 0 ? contentWords.length : words.length))
                );
                
                // æ”¶é›†è¦æŒ–ç©ºçš„è©ï¼ˆç¢ºä¿æ˜¯æœ‰æ•ˆçš„å­—ä¸²ï¼Œä¸åŒ…å«æ¨™é»ï¼‰
                blanksSet.forEach(word => {
                    const cleanWord = String(word).trim();
                    if (cleanWord && isNaN(cleanWord)) {
                        allWords.push(cleanWord);
                    }
                });
                
                const sentenceHtml = words.map((word, wordIndex) => {
                    if (blanksSet.has(word)) {
                        return `<span class="slot" data-correct="${word.replace(/"/g, '&quot;')}" data-sentence="${sentenceIndex}" data-word="${wordIndex}"></span>`;
                    }
                    return `<span class="game-text">${word}</span>`;
                }).join(' ');
                
                return `
                    <div class="sentence-wrapper">
                        <div class="mb-2">${sentenceHtml}${punctuation}</div>
                        <div class="text-sm text-gray-500 italic">${sentence.zh}</div>
                    </div>
                `;
            }).join('');
            
            // éæ¿¾ä¸¦æ’åºå­—å¡ï¼ˆç§»é™¤æ•¸å­—å’Œç©ºå€¼ï¼‰
            const validWords = allWords.filter(w => {
                const word = String(w).trim();
                return word && isNaN(word) && word.length > 0;
            });
            
            const sortedWords = [...validWords].sort((a, b) => 
                a.toLowerCase().localeCompare(b.toLowerCase())
            );
            
            wordBank.innerHTML = sortedWords.map(word => 
                `<div class="word-card" data-word="${word.replace(/"/g, '&quot;')}">${word}</div>`
            ).join('');
            
            bindDragEvents();
        }

        function bindDragEvents() {
            const wordCards = document.querySelectorAll('.word-card');
            const slots = document.querySelectorAll('.slot');
            
            // ç§»é™¤èˆŠçš„äº‹ä»¶ç›£è½å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
            
            wordCards.forEach(card => {
                // è§¸æ§äº‹ä»¶
                card.addEventListener('touchstart', handleTouchStart, { passive: false });
                // æ»‘é¼ äº‹ä»¶ï¼ˆæ¡Œé¢æ”¯æ´ï¼‰
                card.addEventListener('mousedown', handleMouseDown);
                card.addEventListener('click', handleWordClick);
            });
            
            slots.forEach(slot => {
                // è§¸æ§äº‹ä»¶
                slot.addEventListener('touchstart', handleSlotTouchStart, { passive: false });
                // æ»‘é¼ äº‹ä»¶
                slot.addEventListener('mousedown', handleSlotMouseDown);
                slot.addEventListener('click', handleSlotClick);
            });
            
            // å…¨åŸŸç§»å‹•å’ŒçµæŸäº‹ä»¶
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: false });
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }

        function handleWordClick(e) {
            const target = e.target.closest('.word-card');
            if (!target) return;
            
            const word = target.dataset.word || target.textContent.trim();
            
            if (!quickFillMode) {
                // é¸æ“‡æ¨¡å¼
                document.querySelectorAll('.word-card').forEach(c => c.classList.remove('ring-2', 'ring-indigo-500'));
                target.classList.add('ring-2', 'ring-indigo-500');
                selectedWord = word;
            } else {
                // å¿«é€Ÿå¡«å……æ¨¡å¼
                const emptySlot = document.querySelector('.slot:not(.filled)');
                if (emptySlot) {
                    fillSlot(emptySlot, word);
                    target.remove();
                }
            }
        }

        function handleSlotClick(e) {
            const slot = e.target.closest('.slot');
            if (!slot) return;
            
            // é˜²æ­¢æ‹–å‹•æ™‚è§¸ç™¼é»æ“Š
            if (dragState.isDragging) return;
            
            if (slot.classList.contains('filled')) {
                // é»æ“Šå·²å¡«å……çš„æ§½ä½ - æ­¸é‚„å­—åº«ï¼ˆåƒ…åœ¨æœªé¸æ“‡å­—å¡æ™‚ï¼‰
                if (!selectedWord) {
                    returnWordToBank(slot);
                }
                return;
            }
            
            if (selectedWord && !quickFillMode) {
                // ä½¿ç”¨é¸ä¸­çš„å­—å¡«å……ç©ºæ§½
                fillSlot(slot, selectedWord);
                const wordCard = document.querySelector(`.word-card.ring-2.ring-indigo-500`);
                if (wordCard) wordCard.remove();
                selectedWord = null;
                document.querySelectorAll('.word-card').forEach(c => c.classList.remove('ring-2', 'ring-indigo-500'));
            }
        }

        function handleTouchStart(e) {
            const touch = e.touches[0];
            const target = e.target.closest('.word-card');
            if (!target) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            dragState.isDragging = true;
            dragState.sourceElement = target;
            dragState.sourceType = 'bank';
            dragState.touchIdentifier = touch.identifier;
            
            // å‰µå»ºè™›å½± - ä¿ç•™å®Œæ•´å…§å®¹
            const ghost = target.cloneNode(true);
            ghost.className = target.className + ' dragging-clone';
            ghost.style.position = 'fixed';
            ghost.style.left = touch.clientX - target.offsetWidth / 2 + 'px';
            ghost.style.top = touch.clientY - target.offsetHeight / 2 + 'px';
            ghost.style.pointerEvents = 'none';
            ghost.style.zIndex = '9999';
            document.body.appendChild(ghost);
            dragState.ghostElement = ghost;
            
            target.style.opacity = '0.5';
        }

        function handleSlotTouchStart(e) {
            const touch = e.touches[0];
            const target = e.target.closest('.slot.filled');
            if (!target) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            dragState.isDragging = true;
            dragState.sourceElement = target;
            dragState.sourceType = 'slot';
            dragState.touchIdentifier = touch.identifier;
            
            const word = target.textContent.trim();
            const ghost = document.createElement('div');
            ghost.className = 'word-card dragging-clone';
            ghost.textContent = word;
            ghost.style.position = 'fixed';
            ghost.style.left = touch.clientX - 50 + 'px';
            ghost.style.top = touch.clientY - 25 + 'px';
            ghost.style.pointerEvents = 'none';
            ghost.style.zIndex = '9999';
            document.body.appendChild(ghost);
            dragState.ghostElement = ghost;
            
            target.style.opacity = '0.5';
        }

        function handleTouchMove(e) {
            if (!dragState.isDragging) return;
            
            const touch = Array.from(e.touches).find(t => t.identifier === dragState.touchIdentifier);
            if (!touch) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const ghost = dragState.ghostElement;
            if (!ghost) return;
            
            ghost.style.left = touch.clientX - ghost.offsetWidth / 2 + 'px';
            ghost.style.top = touch.clientY - ghost.offsetHeight / 2 + 'px';
            
            // æª¢æ¸¬ä¸‹æ–¹å…ƒç´ 
            ghost.style.display = 'none';
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            ghost.style.display = 'block';
            
            // é«˜äº®å¯æ”¾ç½®å€åŸŸ
            document.querySelectorAll('.drop-zone').forEach(el => el.classList.remove('drop-zone'));
            const dropTarget = elementBelow?.closest('.slot');
            if (dropTarget) {
                dropTarget.classList.add('drop-zone');
            }
        }

        function handleTouchEnd(e) {
            if (!dragState.isDragging) return;
            
            const touch = Array.from(e.changedTouches).find(t => t.identifier === dragState.touchIdentifier);
            if (!touch) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            if (dragState.sourceElement) {
                dragState.sourceElement.style.opacity = '1';
            }
            
            if (dragState.ghostElement) {
                dragState.ghostElement.remove();
            }
            
            const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
            const dropTarget = elementBelow?.closest('.slot');
            
            if (dropTarget) {
                handleDrop(dragState.sourceElement, dropTarget);
            } else if (dragState.sourceType === 'slot') {
                returnWordToBank(dragState.sourceElement);
            }
            
            document.querySelectorAll('.drop-zone').forEach(el => el.classList.remove('drop-zone'));
            dragState = { isDragging: false, sourceElement: null, sourceType: null, ghostElement: null, touchIdentifier: null };
        }

        // ========== æ»‘é¼ äº‹ä»¶è™•ç†ï¼ˆæ¡Œé¢æ”¯æ´ï¼‰========== 
        function handleMouseDown(e) {
            const target = e.target.closest('.word-card');
            if (!target) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            dragState.isDragging = true;
            dragState.sourceElement = target;
            dragState.sourceType = 'bank';
            
            // å‰µå»ºè™›å½± - ä¿ç•™å®Œæ•´å…§å®¹
            const ghost = target.cloneNode(true);
            ghost.className = target.className + ' dragging-clone';
            ghost.style.position = 'fixed';
            ghost.style.left = e.clientX - target.offsetWidth / 2 + 'px';
            ghost.style.top = e.clientY - target.offsetHeight / 2 + 'px';
            ghost.style.pointerEvents = 'none';
            ghost.style.zIndex = '9999';
            document.body.appendChild(ghost);
            dragState.ghostElement = ghost;
            
            target.style.opacity = '0.5';
        }

        function handleSlotMouseDown(e) {
            const target = e.target.closest('.slot.filled');
            if (!target) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            dragState.isDragging = true;
            dragState.sourceElement = target;
            dragState.sourceType = 'slot';
            
            const word = target.textContent.trim();
            const ghost = document.createElement('div');
            ghost.className = 'word-card dragging-clone';
            ghost.textContent = word;
            ghost.style.position = 'fixed';
            ghost.style.left = e.clientX - 50 + 'px';
            ghost.style.top = e.clientY - 25 + 'px';
            ghost.style.pointerEvents = 'none';
            ghost.style.zIndex = '9999';
            document.body.appendChild(ghost);
            dragState.ghostElement = ghost;
            
            target.style.opacity = '0.5';
        }

        function handleMouseMove(e) {
            if (!dragState.isDragging) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            const ghost = dragState.ghostElement;
            if (!ghost) return;
            
            ghost.style.left = e.clientX - ghost.offsetWidth / 2 + 'px';
            ghost.style.top = e.clientY - ghost.offsetHeight / 2 + 'px';
            
            // æª¢æ¸¬ä¸‹æ–¹å…ƒç´ 
            ghost.style.display = 'none';
            const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
            ghost.style.display = 'block';
            
            // é«˜äº®å¯æ”¾ç½®å€åŸŸ
            document.querySelectorAll('.drop-zone').forEach(el => el.classList.remove('drop-zone'));
            const dropTarget = elementBelow?.closest('.slot');
            if (dropTarget) {
                dropTarget.classList.add('drop-zone');
            }
        }

        function handleMouseUp(e) {
            if (!dragState.isDragging) return;
            
            e.preventDefault();
            e.stopPropagation();
            
            if (dragState.sourceElement) {
                dragState.sourceElement.style.opacity = '1';
            }
            
            if (dragState.ghostElement) {
                dragState.ghostElement.remove();
            }
            
            const elementBelow = document.elementFromPoint(e.clientX, e.clientY);
            const dropTarget = elementBelow?.closest('.slot');
            
            if (dropTarget) {
                handleDrop(dragState.sourceElement, dropTarget);
            } else if (dragState.sourceType === 'slot') {
                returnWordToBank(dragState.sourceElement);
            }
            
            document.querySelectorAll('.drop-zone').forEach(el => el.classList.remove('drop-zone'));
            dragState = { isDragging: false, sourceElement: null, sourceType: null, ghostElement: null, touchIdentifier: null };
        }

        function handleDrop(source, target) {
            // å®‰å…¨åœ°æå–å–®å­— - å„ªå…ˆä½¿ç”¨ dataset
            let word = '';
            
            if (source.dataset.filled) {
                // å¾å·²å¡«å……çš„æ§½ä½
                word = source.dataset.filled;
            } else if (source.dataset.word) {
                // å¾å­—åº«å­—å¡
                word = source.dataset.word;
            } else if (source.firstChild && source.firstChild.nodeType === Node.TEXT_NODE) {
                // ç›´æ¥å¾æ–‡å­—ç¯€é»æå–
                word = source.firstChild.textContent.trim();
            } else {
                // æœ€å¾Œæ‰‹æ®µï¼šä½¿ç”¨ textContentï¼ˆå¯èƒ½ä¸æº–ç¢ºï¼‰
                word = source.textContent.trim();
            }
            
            // é©—è­‰æ˜¯å¦ç‚ºæœ‰æ•ˆå–®å­—
            if (!word || word.length === 0 || !isNaN(word)) {
                console.error('Invalid word detected:', word, 'from', source);
                return;
            }
            
            console.log('Dropping word:', word, 'from', dragState.sourceType, 'to slot');
            
            if (!target.classList.contains('filled')) {
                // ç›®æ¨™æ˜¯ç©ºæ§½
                fillSlot(target, word);
                if (dragState.sourceType === 'slot') {
                    clearSlot(source);
                } else {
                    source.remove();
                }
            } else {
                // ç›®æ¨™å·²å¡«å…… - æ–°é‚è¼¯ï¼šèˆŠå­—é€€å›å­—åº«
                const oldWord = target.dataset.filled || target.textContent.trim();
                
                // å…ˆæŠŠèˆŠå­—é€€å›å­—åº«ï¼ˆé©—è­‰æœ‰æ•ˆæ€§ï¼‰
                if (oldWord && oldWord.length > 0 && isNaN(oldWord)) {
                    addWordToBank(oldWord);
                    console.log('Old word returned to bank:', oldWord);
                }
                
                // å¡«å…¥æ–°å­—
                fillSlot(target, word);
                
                // è™•ç†ä¾†æº
                if (dragState.sourceType === 'slot') {
                    clearSlot(source); // ä¾†æºæ§½ä½æ¸…ç©º
                } else {
                    source.remove(); // ä¾†æºå­—å¡ç§»é™¤
                }
            }
        }

        function fillSlot(slot, word) {
            // å¾¹åº•æ¸…ç©ºæ§½ä½å…§å®¹
            while (slot.firstChild) {
                slot.removeChild(slot.firstChild);
            }
            
            // åªè¨­å®šç´”æ–‡å­—å…§å®¹
            const cleanWord = String(word).trim();
            const textNode = document.createTextNode(cleanWord);
            slot.appendChild(textNode);
            
            // è¨­å®šæ¨£å¼å’Œå±¬æ€§
            slot.classList.add('filled');
            slot.dataset.filled = cleanWord;
        }

        function clearSlot(slot) {
            // æ¸…ç©ºæ‰€æœ‰å…§å®¹
            while (slot.firstChild) {
                slot.removeChild(slot.firstChild);
            }
            
            // ç§»é™¤æ¨£å¼
            slot.classList.remove('filled', 'correct-lock', 'wrong-shake');
            delete slot.dataset.filled;
        }

        function returnWordToBank(slot) {
            // å„ªå…ˆä½¿ç”¨ dataset.filled
            const word = slot.dataset.filled || slot.textContent.trim();
            
            if (!word || !isNaN(word)) {
                console.error('Invalid word in slot:', word);
                return;
            }
            
            clearSlot(slot);
            addWordToBank(word);
        }

        function addWordToBank(word) {
            const cleanWord = String(word).trim();
            
            // åš´æ ¼é©—è­‰
            if (!cleanWord || cleanWord.length === 0 || !isNaN(cleanWord)) {
                console.error('Attempting to add invalid word to bank:', word);
                return;
            }
            
            const bank = document.getElementById('word-bank');
            const words = Array.from(bank.children).map(el => el.dataset.word || el.textContent.trim());
            
            // æª¢æŸ¥æ˜¯å¦å·²å­˜åœ¨
            if (words.includes(cleanWord)) {
                console.log('Word already exists in bank:', cleanWord);
                return;
            }
            
            words.push(cleanWord);
            
            // éæ¿¾ç„¡æ•ˆå€¼ä¸¦å»é‡æ’åº
            const validWords = words.filter(w => {
                const word = String(w).trim();
                return word && word.length > 0 && isNaN(word);
            });
            
            const uniqueWords = [...new Set(validWords)];
            uniqueWords.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
            
            bank.innerHTML = uniqueWords.map(w => 
                `<div class="word-card" data-word="${w.replace(/"/g, '&quot;')}">${w}</div>`
            ).join('');
            
            // é‡æ–°ç¶å®šæ‰€æœ‰å­—å¡çš„äº‹ä»¶
            bank.querySelectorAll('.word-card').forEach(card => {
                card.addEventListener('touchstart', handleTouchStart, { passive: false });
                card.addEventListener('mousedown', handleMouseDown);
                card.addEventListener('click', handleWordClick);
            });
        }

        function checkLevel() {
            let allCorrect = true;
            let hasEmpty = false;
            let emptyReminderShown = false; // æ–°å¢ï¼šè¿½è¹¤æ˜¯å¦å·²æé†’
            
            document.querySelectorAll('.slot').forEach(slot => {
                // å„ªå…ˆä½¿ç”¨ dataset.filledï¼Œå¦å‰‡ä½¿ç”¨ textContent
                const userAnswer = slot.dataset.filled || slot.textContent.trim();
                const correctAnswer = slot.dataset.correct;
                
                if (!userAnswer) {
                    hasEmpty = true;
                    // åªåœ¨ç¬¬ä¸€æ¬¡æª¢æŸ¥æ™‚æé†’
                    if (!emptyReminderShown) {
                        emptyReminderShown = true;
                    }
                    return;
                }
                
                if (userAnswer === correctAnswer) {
                    slot.classList.add('correct-lock');
                    slot.classList.remove('wrong-shake');
                } else {
                    slot.classList.add('wrong-shake');
                    slot.classList.remove('correct-lock');
                    allCorrect = false;
                    setTimeout(() => slot.classList.remove('wrong-shake'), 1000);
                }
            });
            
            // ä¿®æ”¹ï¼šåªåœ¨æœ‰ç©ºæ ¼ä¸”æœ¬æ¬¡æª¢æŸ¥æ˜¯ç¬¬ä¸€æ¬¡æœ‰ç©ºæ ¼æ™‚æé†’
            if (hasEmpty) {
                const lastCheckHadEmpty = storage.get('last-check-had-empty', false);
                if (!lastCheckHadEmpty) {
                    showToast('è«‹å¡«å¯«æ‰€æœ‰ç©ºæ ¼ï¼', 'warning');
                    storage.set('last-check-had-empty', true);
                }
                return;
            }
            
            // é‡ç½®æé†’ç‹€æ…‹
            storage.set('last-check-had-empty', false);
            
            if (allCorrect) {
                handleLevelComplete();
            } else {
                showToast('æœ‰äº›åœ°æ–¹ä¸å°å“¦ï¼Œå†è©¦è©¦çœ‹ï¼', 'error');
            }
        }

        function handleLevelComplete() {
            stopTimer();
            saveProgress();
            
            const timeElapsed = Math.floor((Date.now() - startTime) / 1000);
            document.getElementById('final-time').textContent = formatTime(timeElapsed);
            document.getElementById('final-difficulty').textContent = currentDifficulty + '%';
            
            const level = levelsDB[currentLevel];
            document.getElementById('full-text-review').innerHTML = level.sentences.map((s, i) => `
                <div class="mb-3">
                    <div class="font-semibold text-gray-800">${i + 1}. ${s.en}</div>
                    <div class="text-sm text-gray-600 italic">${s.zh}</div>
                </div>
            `).join('');
            
            document.getElementById('report-date').textContent = new Date().toLocaleDateString('zh-TW');
            document.getElementById('report-level').textContent = level.title;
            document.getElementById('report-time').textContent = formatTime(timeElapsed);
            document.getElementById('report-sentences').innerHTML = level.sentences.map((s, i) => `
                <div style="margin-bottom: 15px;">
                    <div style="font-weight: 600; color: #1e293b;">${i + 1}. ${s.en}</div>
                    <div style="color: #64748b; font-size: 14px;">${s.zh}</div>
                </div>
            `).join('');
            
            showEndScreen();
            showToast('ğŸ‰ æ­å–œéé—œï¼', 'success');
        }

        function saveProgress() {
            const progress = storage.get('game-progress', {});
            const timeElapsed = Math.floor((Date.now() - startTime) / 1000);
            
            progress[currentLevel] = {
                completed: true,
                time: timeElapsed,
                difficulty: currentDifficulty,
                date: new Date().toISOString()
            };
            
            storage.set('game-progress', progress);
        }

        /* ========== 7. è¨ˆæ™‚å™¨ ========== */
        function startTimer() {
            startTime = Date.now();
            gameTimer = setInterval(() => {
                const elapsed = Math.floor((Date.now() - startTime) / 1000);
                document.getElementById('timer').textContent = formatTime(elapsed);
            }, 1000);
        }

        function stopTimer() {
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
        }

        /* ========== 8. æˆªåœ–åŠŸèƒ½ ========== */
        async function captureReport() {
            const reportEl = document.getElementById('report-container');
            const downloadBtn = document.getElementById('download-report-btn');
            
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'ç”Ÿæˆä¸­...';
            
            try {
                reportEl.classList.remove('hidden');
                
                const canvas = await html2canvas(reportEl, {
                    scale: 2,
                    useCORS: true,
                    logging: false,
                    backgroundColor: '#ffffff'
                });
                
                reportEl.classList.add('hidden');
                
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = `game-report-${Date.now()}.png`;
                    link.href = url;
                    link.click();
                    
                    setTimeout(() => URL.revokeObjectURL(url), 100);
                    
                    downloadBtn.disabled = false;
                    downloadBtn.textContent = 'ä¸‹è¼‰å ±å‘Š';
                    showToast('å ±å‘Šå·²ä¸‹è¼‰ï¼', 'success');
                }, 'image/png');
                
            } catch (error) {
                console.error('Screenshot error:', error);
                reportEl.classList.add('hidden');
                downloadBtn.disabled = false;
                downloadBtn.textContent = 'ä¸‹è¼‰å ±å‘Š';
                showToast('æˆªåœ–å¤±æ•—ï¼Œè«‹ç¨å¾Œå†è©¦', 'error');
            }
        }

        /* ========== 9. äº‹ä»¶ç¶å®š ========== */
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentDifficulty = parseInt(btn.dataset.difficulty);
                    document.getElementById('current-difficulty').innerHTML = 
                        `ç›®å‰é›£åº¦: <span class="font-bold text-indigo-600">${currentDifficulty}% (${btn.textContent.split('\n')[0]})</span>`;
                    storage.set('last-difficulty', currentDifficulty);
                });
            });
            
            let fontSize = 18;
            document.getElementById('font-increase').addEventListener('click', () => {
                if (fontSize < 32) {
                    fontSize += 2;
                    document.documentElement.style.setProperty('--game-font-size', fontSize + 'px');
                    showToast(`å­—é«”å¤§å°: ${fontSize}px`, 'success');
                } else {
                    showToast('å·²é”æœ€å¤§å­—é«”', 'warning');
                }
            });
            
            document.getElementById('font-decrease').addEventListener('click', () => {
                if (fontSize > 14) {
                    fontSize -= 2;
                    document.documentElement.style.setProperty('--game-font-size', fontSize + 'px');
                    showToast(`å­—é«”å¤§å°: ${fontSize}px`, 'success');
                } else {
                    showToast('å·²é”æœ€å°å­—é«”', 'warning');
                }
            });
            
            document.getElementById('quick-fill-toggle').addEventListener('change', (e) => {
                quickFillMode = e.target.checked;
            });
            
            document.getElementById('check-btn').addEventListener('click', checkLevel);
            
            document.getElementById('back-btn').addEventListener('click', () => {
                if (confirm('ç¢ºå®šè¦é›¢é–‹ï¼Ÿé€²åº¦å°‡ä¸æœƒä¿å­˜ã€‚')) {
                    stopTimer();
                    showHomeScreen();
                }
            });
            
            document.getElementById('download-report-btn').addEventListener('click', captureReport);
            document.getElementById('back-home-btn').addEventListener('click', showHomeScreen);
            document.getElementById('next-level-btn').addEventListener('click', () => {
                const allLevels = groupsConfig.flatMap(g => g.levels);
                const currentIndex = allLevels.indexOf(currentLevel);
                if (currentIndex < allLevels.length - 1) {
                    startLevel(allLevels[currentIndex + 1]);
                } else {
                    showToast('æ­å–œå®Œæˆæ‰€æœ‰é—œå¡ï¼', 'success');
                    showHomeScreen();
                }
            });
            
            const lastDifficulty = storage.get('last-difficulty', 60);
            currentDifficulty = lastDifficulty;
            
            showHomeScreen();
            
            setTimeout(() => {
                if (!window.html2canvas) {
                    console.warn('html2canvas failed to load');
                }
            }, 2000);
        });
    </script>
</body>
</html>
